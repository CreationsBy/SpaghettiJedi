<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AR Party Game</title>
    <style>
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; height: 100dvh; 
            overflow: hidden; background: #000; color: white; font-family: 'Arial', sans-serif; 
            user-select: none; -webkit-user-select: none;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #ui-layer { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100dvh; 
            z-index: 10; pointer-events: none; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
        }

        .panel { 
            background: rgba(0, 10, 20, 0.95); padding: 25px; border-radius: 20px; 
            border: 2px solid #00d2ff; pointer-events: auto; width: 85%; max-width: 350px; 
            text-align: center; box-shadow: 0 0 30px rgba(0, 210, 255, 0.2);
            display: flex; flex-direction: column; gap: 12px;
        }
        .hidden { display: none !important; }

        h1 { margin: 0; color: #00d2ff; font-size: 1.5rem; letter-spacing: 2px; }
        p { color: #ccc; margin: 0; font-size: 0.9rem; }
        
        input { 
            background: #222; border: 2px solid #444; color: white; padding: 15px; 
            border-radius: 12px; width: 100%; box-sizing: border-box; font-size: 1.5rem; 
            text-align: center; letter-spacing: 5px; font-weight: bold;
        }
        
        button { 
            background: linear-gradient(135deg, #00d2ff, #0077be); color: white; border: none; 
            padding: 15px; width: 100%; font-size: 1.1rem; font-weight: bold; 
            border-radius: 12px; cursor: pointer; transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        .btn-green { background: #28a745; }
        .btn-red { background: #ff4444; margin-top: 10px; }
        .btn-secondary { background: #444; }

        #hud { 
            position: absolute; top: 10px; left: 10px; z-index: 5; font-weight: bold; 
            text-shadow: 1px 1px 0 #000; pointer-events: none; padding-top: env(safe-area-inset-top);
            font-size: 1.2rem;
            display: none; 
        }
        
        #local-preview {
            position: absolute; bottom: 20px; right: 20px; width: 80px; height: auto;
            border: 2px solid #00d2ff; border-radius: 10px; z-index: 5; background: black;
            transform: scaleX(-1);
        }
        
        #track-status {
            position: absolute; bottom: 105px; right: 25px; z-index: 6; font-size: 20px;
            display: none;
        }

        #loader { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000;
            z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        /* HIDDEN VIDEO SOURCE - Must exist for texture binding */
        #webcam-source { position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0; pointer-events: none; }
    </style>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      { "imports": { "three": "https://unpkg.com/three@0.154.0/build/three.module.js" } }
    </script>
</head>
<body>

    <video id="webcam-source" playsinline autoplay muted></video>
    <div id="canvas-container"></div>
    <canvas id="local-preview"></canvas>

    <div id="hud">
        <div id="game-info">Waiting...</div>
        <div id="sub-info" style="font-size: 0.8em; color: yellow;"></div>
    </div>

    <div id="loader"><h2 style="color: #00d2ff;">Loading System...</h2></div>

    <div id="ui-layer">
        <div id="main-menu" class="panel hidden">
            <h1>AR Party</h1>
            <p>1. Pick a 4-Digit Code</p>
            <input type="tel" id="room-code-input" placeholder="0000" maxlength="4">
            <p style="margin-top:10px;">2. Start:</p>
            <div style="display:flex; gap:10px; width:100%;">
                <button class="btn-green" onclick="app.host()">Create Room</button>
                <button onclick="app.join()">Join Room</button>
            </div>
        </div>

        <div id="lobby-panel" class="panel hidden">
            <h1 id="lobby-code-display">Room: ????</h1>
            <p id="player-count">Waiting for player...</p>
            <hr style="width:100%; border:0; border-top:1px solid #444;">
            <div id="host-controls" class="hidden">
                <h3>Select Game</h3>
                <button onclick="gameManager.selectGame('track')">üèÉ Track Run</button>
                <button onclick="gameManager.selectGame('swim')">üèä Ocean Swim</button>
                <button onclick="gameManager.selectGame('heads-up')">ü§î Heads Up</button>
            </div>
            <div id="client-wait" class="hidden"><p>Waiting for Host...</p></div>
            <button class="btn-red" onclick="app.backToMenu()">‚¨Ö Back to Menu</button>
        </div>

        <div id="calibration-panel" class="panel hidden">
            <h1>Get Ready</h1>
            <p id="calib-instr">...</p>
            <div id="calib-status" style="background:#330000; color:#ff5555; padding:10px; border-radius:5px;">Not Detected</div>
            <button id="start-btn" disabled onclick="gameManager.requestStartGame()">START</button>
        </div>

        <div id="result-panel" class="panel hidden">
            <h1>Game Over</h1>
            <p id="result-text" style="line-height: 1.5; font-size: 1.2em;"></p>
            <button class="btn-green" onclick="gameManager.playAgain()">üîÑ Play Again</button>
            <button class="btn-secondary" onclick="gameManager.returnToLobby()">Back to Lobby</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        const ID_PREFIX = "AR_GAME_ROOM_";

        // --- UI MANAGER ---
        class UIManager {
            constructor() { 
                this.panels = document.querySelectorAll('.panel'); 
                this.loader = document.getElementById('loader');
                this.hud = document.getElementById('hud');
            }
            hideAllPanels() { this.panels.forEach(p => p.classList.add('hidden')); }
            showPanel(id) { 
                this.hideAllPanels(); 
                document.getElementById(id).classList.remove('hidden'); 
                this.hud.style.display = 'none';
            }
            showHUD() {
                this.hideAllPanels();
                this.hud.style.display = 'block';
            }
            showLoader(msg) {
                this.loader.classList.remove('hidden');
                this.loader.querySelector('h2').innerText = msg;
            }
            hideLoader() { this.loader.classList.add('hidden'); }
        }

        // --- NETWORK MANAGER ---
        class NetworkManager {
            constructor() {
                this.peer = null; this.conn = null;
                this.isHost = false; this.roomCode = ""; this.connected = false;
            }
            reset() {
                if(this.peer) { this.peer.destroy(); this.peer = null; }
                this.conn = null; this.connected = false;
            }
            hostRoom(code) { this.reset(); this.roomCode = code; this.isHost = true; this.initPeer(ID_PREFIX + code); }
            joinRoom(code) { this.reset(); this.roomCode = code; this.isHost = false; this.initPeer(null); }

            initPeer(customID) {
                ui.showLoader("Connecting...");
                try {
                    this.peer = new Peer(customID);
                    this.peer.on('open', (id) => {
                        ui.hideLoader();
                        if(this.isHost) this.setupLobbyUI();
                        else this.connectToHost(ID_PREFIX + this.roomCode);
                    });
                    this.peer.on('error', (err) => {
                        ui.hideLoader(); alert("Network Error: " + err.type); this.reset(); ui.showPanel('main-menu');
                    });
                    this.peer.on('connection', (c) => this.handleDataConnection(c));
                    
                    // ANSWER CALL AND SEND STREAM
                    this.peer.on('call', (call) => {
                        const stream = visionManager.getStream(); 
                        if(stream) {
                            call.answer(stream);
                            call.on('stream', (remoteStream) => sceneManager.addRemotePlayer(remoteStream));
                        }
                    });
                } catch(e) { ui.hideLoader(); alert("Peer Error: " + e); }
            }

            connectToHost(hostID) {
                ui.showLoader("Finding Room...");
                this.conn = this.peer.connect(hostID);
                this.conn.on('open', () => {
                    ui.hideLoader(); this.connected = true; this.setupLobbyUI();
                    this.conn.send({ type: 'join' });
                    // CALL HOST AND SEND STREAM
                    const stream = visionManager.getStream();
                    if(stream) {
                        const call = this.peer.call(hostID, stream);
                        call.on('stream', (remoteStream) => sceneManager.addRemotePlayer(remoteStream));
                    }
                });
                this.conn.on('data', (data) => this.handleData(data));
                setTimeout(() => { if(!this.connected) { ui.hideLoader(); alert("Host not found"); ui.showPanel('main-menu'); }}, 5000);
            }

            setupLobbyUI() {
                ui.showPanel('lobby-panel');
                document.getElementById('lobby-code-display').innerText = "Room: " + this.roomCode;
                if(this.isHost) {
                    document.getElementById('host-controls').classList.remove('hidden');
                    document.getElementById('client-wait').classList.add('hidden');
                    document.getElementById('player-count').innerText = "Waiting for friend...";
                } else {
                    document.getElementById('host-controls').classList.add('hidden');
                    document.getElementById('client-wait').classList.remove('hidden');
                    document.getElementById('player-count').innerText = "Connected to Host!";
                }
            }

            handleDataConnection(conn) {
                this.conn = conn; this.connected = true;
                conn.on('data', (data) => this.handleData(data));
                conn.on('open', () => { 
                    if(this.isHost) {
                        document.getElementById('player-count').innerText = "Friend Connected!";
                        sceneManager.repositionAvatars();
                    }
                });
            }

            handleData(data) {
                if(data.type === 'game_start') gameManager.startGame(data.gameType);
                if(data.type === 'game_update') gameManager.syncState(data);
                if(data.type === 'assign_word') gameManager.setHeadsUpWord(data.word, data.target);
            }
            send(data) { if(this.conn && this.conn.open) this.conn.send(data); }
        }

        // --- GAME MANAGER ---
        class GameManager {
            constructor() {
                this.currentGame = null; this.isPlaying = false; this.myWord = "";
                this.words = ["PIZZA", "TIGER", "ALIEN", "ROBOT", "GHOST", "BANANA", "ELEPHANT", "NINJA", "PIRATE", "ZOMBIE", "CHICKEN", "SUPERMAN", "BATMAN", "SPIDERMAN", "PRINCESS", "COWBOY", "ASTRONAUT", "DINOSAUR", "MONKEY", "LION", "CAT", "DOG", "FROG", "PENGUIN", "GUITAR", "DRUMS", "SINGER", "DANCER", "TEACHER", "DOCTOR", "ICECREAM", "HAMBURGER", "TACO", "APPLE", "PUMPKIN"];
                this.wordDeck = [...this.words];
                this.speech = null;
                if('webkitSpeechRecognition' in window) {
                    this.speech = new webkitSpeechRecognition();
                    this.setupSpeech();
                }
                this.trackDist=0; this.remoteDist=0; this.raceLength=100;
                this.swimHeight=0; this.remoteSwimHeight=0; this.swimOxygen=10; this.maxOxygenTime=10; this.isUnderwater=false;
            }

            getUniqueWord() {
                if(this.wordDeck.length===0) this.wordDeck = [...this.words];
                return this.wordDeck.splice(Math.floor(Math.random()*this.wordDeck.length), 1)[0];
            }

            setupSpeech() {
                this.speech.continuous = true; this.speech.interimResults = true; this.speech.lang = 'en-US';
                this.speech.onresult = (e) => {
                    const t = e.results[e.results.length-1][0].transcript.toUpperCase();
                    if(this.currentGame==='heads-up' && this.myWord && t.includes(this.myWord)) this.handleWin();
                };
            }

            selectGame(type) {
                if(networkManager.isHost) {
                    networkManager.send({ type: 'game_start', gameType: type });
                    this.startGame(type);
                }
            }
            requestStartGame() {
                this.startActualGameplay();
                if(networkManager.isHost) networkManager.send({ type: 'game_update', action: 'start_play' });
            }

            startGame(type) {
                this.currentGame = type; ui.showPanel('calibration-panel'); sceneManager.setEnvironment(type);
                this.trackDist=0; this.remoteDist=0; this.swimHeight=0; this.remoteSwimHeight=0; this.swimOxygen=10; this.maxOxygenTime=10; this.isUnderwater=false;
                document.getElementById('sub-info').innerText = "";
                
                if(type === 'heads-up') {
                    document.getElementById('calib-instr').innerText = "Look at camera. Guess word on your head!";
                    if(networkManager.isHost) {
                        const w1 = this.getUniqueWord(); this.setHeadsUpWord(w1, 'me');
                        if(networkManager.connected) {
                            const w2 = this.getUniqueWord();
                            networkManager.send({ type: 'assign_word', word: w2, target: 'me' });
                            setTimeout(() => {
                                networkManager.send({ type: 'assign_word', word: w1, target: 'them' });
                                this.setHeadsUpWord(w2, 'them');
                            }, 500);
                        }
                    }
                    if(this.speech) this.speech.start();
                } else document.getElementById('calib-instr').innerText = type==='track' ? "PUMP ARMS to Run!" : "MOVE ARMS UP/DOWN to Swim!";
                
                if(networkManager.isHost) document.getElementById('start-btn').disabled = true;
                else document.getElementById('start-btn').innerText = "Waiting for Host...";
            }

            setHeadsUpWord(word, target) {
                if(target === 'me') {
                    this.myWord = word;
                    if(!networkManager.connected) { document.getElementById('sub-info').innerText = "TEST: Say '" + word + "'"; sceneManager.updateLabel(null); }
                    else sceneManager.updateLabel(null);
                } else sceneManager.updateLabel(word);
            }

            startActualGameplay() { this.isPlaying = true; ui.showHUD(); }
            playAgain() { if(networkManager.isHost) this.selectGame(this.currentGame); else ui.showPanel('lobby-panel'); }

            update(landmarks) {
                if(!this.isPlaying) { // CALIBRATION
                    const ready = landmarks[11].visibility > 0.5 && landmarks[12].visibility > 0.5;
                    const status = document.getElementById('calib-status');
                    if(ready || (this.currentGame==='heads-up' && landmarks[0].visibility>0.8)) {
                        status.style.background="#003300"; status.style.color="#00ff00"; status.innerText="‚úÖ Ready";
                        if(networkManager.isHost) document.getElementById('start-btn').disabled = false;
                    } else {
                        status.style.background="#330000"; status.style.color="#ff5555"; status.innerText="‚ö†Ô∏è Show Body";
                        document.getElementById('start-btn').disabled = true;
                    }
                    return;
                }

                // GAMEPLAY
                if(this.currentGame === 'track') {
                    const energy = visionManager.getMotionEnergy();
                    if(energy > 0.02) {
                        let speed = energy * 0.15; if(speed > 1.2) speed = 1.2;
                        this.trackDist += speed;
                    }
                    if(networkManager.connected) networkManager.send({type:'game_update', action:'move', val:this.trackDist});
                    sceneManager.updateTrackGame(this.trackDist, this.remoteDist);
                    document.getElementById('game-info').innerText = `Dist: ${Math.floor(this.trackDist)}m / 100m`;
                    if(this.trackDist >= 100) this.handleWin("üéâ You Finished!");
                }
                else if(this.currentGame === 'swim') {
                    const energy = visionManager.getMotionEnergy();
                    if(energy > 0.08) this.swimHeight += 0.05;
                    this.swimHeight -= 0.02;
                    if(this.swimHeight > 0.5) this.swimHeight = 0.5; if(this.swimHeight < -5) this.swimHeight = -5;
                    
                    if(networkManager.connected) networkManager.send({type:'game_update', action:'swim_move', val:this.swimHeight});
                    sceneManager.updateSwimVisuals(this.swimHeight, this.remoteSwimHeight);
                    
                    if(this.swimHeight < -0.2) {
                        this.isUnderwater = true; this.swimOxygen -= 0.03; sceneManager.setUnderwaterEffect(true);
                    } else {
                        if(this.isUnderwater) { this.maxOxygenTime = Math.max(3, this.maxOxygenTime-2); this.swimOxygen = this.maxOxygenTime; }
                        this.isUnderwater = false; sceneManager.setUnderwaterEffect(false);
                    }
                    document.getElementById('game-info').innerText = `Depth: ${this.swimHeight.toFixed(1)}m`;
                    document.getElementById('sub-info').innerText = `OXYGEN: ${this.swimOxygen.toFixed(1)}s`;
                    if(this.swimOxygen <= 0) this.handleLoss("üåä You Drowned!");
                }
                else if(this.currentGame === 'heads-up') {
                    sceneManager.updateHeadTracking(landmarks);
                    document.getElementById('game-info').innerText = "GUESS THE WORD!";
                }
            }

            syncState(data) {
                if(data.action==='move') this.remoteDist = data.val;
                if(data.action==='swim_move') this.remoteSwimHeight = data.val;
                if(data.action==='start_play') this.startActualGameplay();
                if(data.action==='win') this.endGame(data.msg);
                if(data.action==='opponent_died') this.endGame("üéâ You Survived!");
            }

            handleWin(msg) {
                let txt = msg;
                if(this.currentGame==='heads-up') txt = "üéâ Great Job!\nThe word was: " + this.myWord;
                if(networkManager.connected) networkManager.send({type:'game_update', action:'win', msg:"Good Try!"});
                this.endGame(txt);
            }
            handleLoss(msg) {
                if(networkManager.connected) networkManager.send({type:'game_update', action:'opponent_died'});
                this.endGame(msg);
            }
            endGame(msg) {
                this.isPlaying = false; if(this.speech) this.speech.stop();
                document.getElementById('result-text').innerText = msg;
                ui.showPanel('result-panel');
            }
            returnToLobby() {
                ui.showPanel('lobby-panel'); sceneManager.setEnvironment('lobby'); this.isPlaying=false; sceneManager.resetCamera();
            }
        }

        // --- VISION MANAGER ---
        class VisionManager {
            constructor() {
                this.canvas = document.getElementById('local-preview');
                this.ctx = this.canvas.getContext('2d');
                this.userCanvas = document.createElement('canvas'); 
                this.userCtx = this.userCanvas.getContext('2d');
                this.video = document.getElementById('webcam-source');
                this.pose = null; this.prevY=0; this.energy=0;
            }

            async preload() {
                // Just load model, don't use video yet
                try {
                    this.pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
                    this.pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, enableSegmentation: true, minDetectionConfidence: 0.5 });
                    this.pose.onResults(this.process.bind(this));
                    await this.pose.initialize();
                } catch(e) { console.error("Model load failed", e); }
            }

            async startCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: true });
                    this.video.srcObject = stream;
                    // Force play logic
                    this.video.onloadedmetadata = () => { this.video.play(); };
                    await this.video.play();
                    this.loop();
                    return true;
                } catch(e) { alert("Camera Error: " + e.message); return false; }
            }

            async loop() {
                requestAnimationFrame(this.loop.bind(this));
                
                // Force video alive
                if(this.video.paused) { try { await this.video.play(); } catch(e){} }

                // Safe Processing
                if(this.video.readyState >= 2 && this.pose && this.video.videoWidth > 0) {
                    try { await this.pose.send({image: this.video}); } catch(e){}
                }
            }

            process(results) {
                const trackStatus = document.getElementById('track-status');
                if(!results.poseLandmarks) { trackStatus.style.display = 'block'; return; }
                else trackStatus.style.display = 'none';

                if(this.canvas.width !== results.image.width) {
                    this.canvas.width = this.userCanvas.width = results.image.width;
                    this.canvas.height = this.userCanvas.height = results.image.height;
                    sceneManager.updateAvatarGeometry(results.image.width / results.image.height);
                }

                // 1. Clear Canvas
                this.userCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                // 2. Draw Mask
                this.userCtx.drawImage(results.segmentationMask, 0, 0, this.canvas.width, this.canvas.height);
                // 3. Composite Source-In (Keeps only masked area)
                this.userCtx.globalCompositeOperation = 'source-in';
                this.userCtx.drawImage(results.image, 0, 0, this.canvas.width, this.canvas.height);
                // 4. Reset Composite
                this.userCtx.globalCompositeOperation = 'source-over';

                // Debug Preview
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.userCanvas, 0, 0);

                sceneManager.updateLocalTexture(this.userCanvas);

                if(results.poseLandmarks) {
                    const wy = results.poseLandmarks[15].y;
                    this.energy = Math.abs(wy - this.prevY) * 10;
                    this.prevY = wy;
                    gameManager.update(results.poseLandmarks);
                }
            }

            getStream() { 
                if(this.canvas.width > 0) return this.userCanvas.captureStream(30); 
                return null; 
            }
            getMotionEnergy() { return this.energy; }
        }

        // --- SCENE MANAGER ---
        class SceneManager {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
                this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.8));

                // Local Avatar
                const geo = new THREE.PlaneGeometry(2, 1.5);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, side: THREE.DoubleSide });
                this.localMesh = new THREE.Mesh(geo, mat);
                this.scene.add(this.localMesh);

                this.remoteMesh = null;
                this.headLabel = this.createLabel("Waiting...");
                this.headLabel.visible = false;
                this.scene.add(this.headLabel);

                this.floor = this.createFloor(); this.scene.add(this.floor);
                this.finishLine = this.createFinishLine(); this.scene.add(this.finishLine);
                this.water = this.createWater(); this.scene.add(this.water);

                this.camera.position.set(0, 1, 0);
                this.repositionAvatars();
                this.animate();
            }

            updateAvatarGeometry(aspect) {
                const height = 1.5; const width = height * aspect;
                this.localMesh.geometry.dispose();
                this.localMesh.geometry = new THREE.PlaneGeometry(width, height);
                this.repositionAvatars();
            }

            createLabel(text) {
                const canvas = document.createElement('canvas');
                canvas.width = 1024; canvas.height = 256;
                return new THREE.Mesh(new THREE.PlaneGeometry(2, 0.5), new THREE.MeshBasicMaterial({map: new THREE.CanvasTexture(canvas), transparent: true}));
            }

            updateLabel(text) {
                if(!text) { this.headLabel.visible = false; return; }
                const ctx = this.headLabel.material.map.image.getContext('2d');
                ctx.fillStyle = 'white'; ctx.fillRect(0,0,1024,256);
                ctx.strokeStyle = '#00d2ff'; ctx.lineWidth = 15; ctx.strokeRect(0,0,1024,256);
                ctx.fillStyle = 'black'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                
                let fontSize = 140;
                ctx.font = `bold ${fontSize}px Arial`;
                while(ctx.measureText(text).width > 900 && fontSize > 40) {
                    fontSize -= 5;
                    ctx.font = `bold ${fontSize}px Arial`;
                }
                ctx.fillText(text, 512, 128);
                this.headLabel.material.map.needsUpdate = true;
                this.headLabel.visible = true;
            }

            updateLocalTexture(canvas) { 
                if(!this.localMesh.material.map) {
                     this.localMesh.material.map = new THREE.CanvasTexture(canvas);
                }
                this.localMesh.material.map.needsUpdate = true; 
            }

            addRemotePlayer(stream) {
                const video = document.createElement('video');
                video.srcObject = stream;
                video.playsInline = true; video.autoplay = true; video.muted = true;
                video.play();

                const tex = new THREE.VideoTexture(video);
                if(this.remoteMesh) this.scene.remove(this.remoteMesh);
                
                const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
                this.remoteMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 1.5), mat);
                this.scene.add(this.remoteMesh);
                
                const updateRemote = () => {
                    if (video.videoWidth && video.videoHeight) {
                        const aspect = video.videoWidth / video.videoHeight;
                        this.remoteMesh.geometry = new THREE.PlaneGeometry(1.5 * aspect, 1.5);
                        this.repositionAvatars();
                    }
                };
                video.addEventListener('resize', updateRemote);
                this.repositionAvatars();
            }

            repositionAvatars() {
                const vH = 3.46; // Visible height at Z=-3
                const vW = vH * (window.innerWidth / window.innerHeight);
                const offsetX = vW * 0.25;
                this.localMesh.position.set(-offsetX, 0, -3);
                if(this.remoteMesh) this.remoteMesh.position.set(offsetX, 0, -3);
            }

            updateTrackGame(myDist, theirDist) {
                this.finishLine.position.z = -100 + myDist; 
                if(this.remoteMesh) this.remoteMesh.position.z = -3 - (theirDist - myDist)*0.1;
            }
            updateSwimVisuals(myHeight, theirHeight) {
                this.localMesh.position.y = myHeight;
                this.camera.position.y = myHeight + 1.0;
                if(this.remoteMesh) this.remoteMesh.position.y = theirHeight;
            }
            updateHeadTracking(landmarks) {
                if(this.remoteMesh && this.headLabel.visible) {
                    this.headLabel.position.copy(this.remoteMesh.position);
                    this.headLabel.position.y += 0.8;
                    this.headLabel.position.z += 0.1;
                }
            }

            createFloor() { return new THREE.Mesh(new THREE.PlaneGeometry(20, 100), new THREE.MeshBasicMaterial({color: 0x222222})); }
            createFinishLine() { 
                const m = new THREE.Mesh(new THREE.PlaneGeometry(10, 2), new THREE.MeshBasicMaterial({color: 0xff0000}));
                m.position.set(0, 1.5, -100); return m;
            }
            createWater() {
                const m = new THREE.Mesh(new THREE.PlaneGeometry(20, 100), new THREE.MeshBasicMaterial({color: 0x006994, transparent:true, opacity:0.8}));
                m.rotation.x = -Math.PI/2; m.position.y = -1; return m;
            }

            setEnvironment(type) {
                this.scene.background = new THREE.Color(type==='lobby'?0x110022 : type==='track'?0x87CEEB : type==='swim'?0x006994 : 0x333333);
                this.scene.fog = (type==='swim') ? new THREE.Fog(0x006994, 0.1, 50) : null;
                this.floor.visible = (type==='track');
                this.finishLine.visible = (type==='track');
                this.water.visible = (type==='swim');
                this.headLabel.visible = (type==='heads-up' && this.remoteMesh!==null);
                this.resetCamera();
            }
            
            resetCamera() {
                this.camera.position.set(0, 1, 0);
                this.repositionAvatars();
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                this.renderer.render(this.scene, this.camera);
            }
        }

        const ui = new UIManager();
        const visionManager = new VisionManager();
        const sceneManager = new SceneManager();
        const gameManager = new GameManager();
        const networkManager = new NetworkManager();
        const app = new App();

        window.app = app; window.gameManager = gameManager;
        
        // SAFE STARTUP
        visionManager.preload().then(() => {
            ui.hideLoader();
            ui.showPanel('main-menu');
        }).catch(() => {
            // Force open even if error
            ui.hideLoader();
            ui.showPanel('main-menu');
        });

    </script>
</body>
</html>