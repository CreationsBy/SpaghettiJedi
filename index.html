<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>AR Party Game</title>
    <style>
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; height: 100dvh; 
            overflow: hidden; background: #000; color: white; font-family: 'Arial', sans-serif; 
            user-select: none; -webkit-user-select: none;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI Layer */
        #ui-layer { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100dvh; 
            z-index: 10; pointer-events: none; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
        }

        .panel { 
            background: rgba(0, 10, 20, 0.95); padding: 25px; border-radius: 20px; 
            border: 2px solid #00d2ff; pointer-events: auto; width: 85%; max-width: 350px; 
            text-align: center; box-shadow: 0 0 30px rgba(0, 210, 255, 0.2);
            display: flex; flex-direction: column; gap: 12px;
        }
        .hidden { display: none !important; }

        h1 { margin: 0; color: #00d2ff; font-size: 1.5rem; letter-spacing: 2px; }
        h3 { margin: 5px 0; color: #aaa; }
        p { color: #ccc; margin: 0; font-size: 0.9rem; }
        
        input { 
            background: #222; border: 2px solid #444; color: white; padding: 15px; 
            border-radius: 12px; width: 100%; box-sizing: border-box; font-size: 1.5rem; 
            text-align: center; letter-spacing: 5px; font-weight: bold;
        }
        input:focus { border-color: #00d2ff; outline: none; }

        button { 
            background: linear-gradient(135deg, #00d2ff, #0077be); color: white; border: none; 
            padding: 15px; width: 100%; font-size: 1.1rem; font-weight: bold; 
            border-radius: 12px; cursor: pointer; transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        .btn-green { background: #28a745; }

        #hud { 
            position: absolute; top: 10px; left: 10px; z-index: 5; font-weight: bold; 
            text-shadow: 1px 1px 0 #000; pointer-events: none; padding-top: env(safe-area-inset-top);
        }
        
        #local-preview {
            position: absolute; bottom: 20px; right: 20px; width: 80px; height: auto;
            border: 2px solid #00d2ff; border-radius: 10px; z-index: 5; background: black;
            transform: scaleX(-1);
        }
        
        #track-status {
            position: absolute; bottom: 105px; right: 25px; z-index: 6; font-size: 20px;
            display: none;
        }

        #loader { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000;
            z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
    </style>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      { "imports": { "three": "https://unpkg.com/three@0.154.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    <canvas id="local-preview"></canvas>
    <div id="track-status">‚ö†Ô∏è Lost</div>

    <div id="hud">
        <div id="game-info">Waiting...</div>
        <div id="mic-status">üé§ Mic On</div>
    </div>

    <div id="loader">
        <h2 style="color: #00d2ff;">Loading System...</h2>
    </div>

    <div id="ui-layer">
        <div id="main-menu" class="panel hidden">
            <h1>AR Party</h1>
            <p>Enter a 4-Digit Room Code:</p>
            <input type="tel" id="room-code-input" placeholder="0000" maxlength="4">
            
            <div style="display:flex; gap:10px;">
                <button class="btn-green" onclick="app.host()">Create Room</button>
                <button onclick="app.join()">Join Room</button>
            </div>
            <p style="font-size:0.8em; color:#888; margin-top:5px;">Tap button to start Camera</p>
        </div>

        <div id="lobby-panel" class="panel hidden">
            <h1 id="lobby-code-display">Room: ????</h1>
            <p id="player-count">Waiting for player...</p>
            <hr style="width:100%; border:0; border-top:1px solid #444;">
            
            <div id="host-controls" class="hidden">
                <h3>Select Game</h3>
                <button onclick="gameManager.selectGame('track')">üèÉ Track Run</button>
                <button onclick="gameManager.selectGame('swim')">üèä Ocean Swim</button>
                <button onclick="gameManager.selectGame('heads-up')">ü§î Heads Up</button>
            </div>
            <div id="client-wait" class="hidden">
                <p>Waiting for Host to pick a game...</p>
            </div>
        </div>

        <div id="calibration-panel" class="panel hidden">
            <h1>Get Ready</h1>
            <p id="calib-instr">...</p>
            <div id="calib-status" style="background:#330000; color:#ff5555; padding:10px; border-radius:5px;">Not Detected</div>
            <button id="start-btn" disabled onclick="gameManager.requestStartGame()">START</button>
        </div>

        <div id="result-panel" class="panel hidden">
            <h1>Game Over</h1>
            <p id="result-text"></p>
            <button onclick="gameManager.returnToLobby()">Back to Lobby</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        const ID_PREFIX = "AR_GAME_ROOM_";

        /* =========================================
           1. UI MANAGER
           ========================================= */
        class UIManager {
            constructor() { 
                this.panels = document.querySelectorAll('.panel'); 
                this.loader = document.getElementById('loader');
            }
            hideAllPanels() { this.panels.forEach(p => p.classList.add('hidden')); }
            showPanel(id) { 
                this.hideAllPanels(); 
                document.getElementById(id).classList.remove('hidden'); 
            }
            showLoader(msg) {
                this.loader.classList.remove('hidden');
                this.loader.querySelector('h2').innerText = msg;
            }
            hideLoader() {
                this.loader.classList.add('hidden');
            }
        }

        /* =========================================
           2. NETWORK MANAGER
           ========================================= */
        class NetworkManager {
            constructor() {
                this.peer = null;
                this.conn = null;
                this.isHost = false;
                this.roomCode = "";
            }

            hostRoom(code) {
                this.roomCode = code;
                this.isHost = true;
                this.initPeer(ID_PREFIX + code);
            }

            joinRoom(code) {
                this.roomCode = code;
                this.isHost = false;
                this.initPeer(null); 
            }

            initPeer(customID) {
                ui.showLoader("Connecting to Network...");
                
                try {
                    this.peer = new Peer(customID);
                    
                    // Timeout safety
                    const timeout = setTimeout(() => {
                        if(!this.peer.open) {
                            alert("Connection timed out. Check internet.");
                            ui.hideLoader();
                            ui.showPanel('main-menu');
                        }
                    }, 10000);

                    this.peer.on('open', (id) => {
                        clearTimeout(timeout);
                        ui.hideLoader();
                        if(this.isHost) {
                            this.setupLobbyUI();
                        } else {
                            this.connectToHost(ID_PREFIX + this.roomCode);
                        }
                    });

                    this.peer.on('error', (err) => {
                        clearTimeout(timeout);
                        ui.hideLoader();
                        alert("Network Error: " + err.type);
                        ui.showPanel('main-menu');
                    });

                    this.peer.on('connection', (c) => this.handleDataConnection(c));
                    this.peer.on('call', (call) => this.handleMediaCall(call));

                } catch(e) {
                    ui.hideLoader();
                    alert("PeerJS Error: " + e);
                }
            }

            connectToHost(hostID) {
                ui.showLoader("Finding Room...");
                this.conn = this.peer.connect(hostID);
                
                this.conn.on('open', () => {
                    ui.hideLoader();
                    this.setupLobbyUI();
                    this.conn.send({ type: 'join' });
                });

                // Safety if host doesn't exist
                setTimeout(() => {
                    if(!this.conn.open) {
                        ui.hideLoader();
                        alert("Room not found or Host offline.");
                        ui.showPanel('main-menu');
                    }
                }, 5000);

                const stream = visionManager.getStream();
                if(stream) {
                    const call = this.peer.call(hostID, stream);
                    this.handleMediaCall(call);
                }
                this.conn.on('data', (data) => this.handleData(data));
            }

            setupLobbyUI() {
                ui.showPanel('lobby-panel');
                document.getElementById('lobby-code-display').innerText = "Room: " + this.roomCode;
                if(this.isHost) {
                    document.getElementById('host-controls').classList.remove('hidden');
                    document.getElementById('client-wait').classList.add('hidden');
                    document.getElementById('player-count').innerText = "Waiting for friend...";
                } else {
                    document.getElementById('host-controls').classList.add('hidden');
                    document.getElementById('client-wait').classList.remove('hidden');
                    document.getElementById('player-count').innerText = "Connected to Host!";
                }
            }

            handleDataConnection(conn) {
                this.conn = conn;
                conn.on('data', (data) => this.handleData(data));
                conn.on('open', () => {
                    if(this.isHost) {
                        document.getElementById('player-count').innerText = "Friend Connected!";
                        const stream = visionManager.getStream();
                        if(stream) this.peer.call(conn.peer, stream);
                    }
                });
            }

            handleMediaCall(call) {
                const stream = visionManager.getStream();
                call.answer(stream); 
                call.on('stream', (remoteStream) => {
                    sceneManager.addRemotePlayer(remoteStream);
                });
            }

            handleData(data) {
                if(data.type === 'game_start') gameManager.startGame(data.gameType);
                if(data.type === 'game_update') gameManager.syncState(data);
                if(data.type === 'assign_word') gameManager.setHeadsUpWord(data.word, data.target);
            }

            send(data) {
                if(this.conn && this.conn.open) this.conn.send(data);
            }
        }

        /* =========================================
           3. GAME MANAGER
           ========================================= */
        class GameManager {
            constructor() {
                this.currentGame = null;
                this.isPlaying = false;
                this.myWord = ""; 
                this.words = ["PIZZA", "TIGER", "ALIEN", "ROBOT", "GHOST", "BANANA"];
                this.speech = null;
                if('webkitSpeechRecognition' in window) {
                    this.speech = new webkitSpeechRecognition();
                    this.setupSpeech();
                }
                this.trackDist = 0;
                this.remoteDist = 0;
            }

            setupSpeech() {
                this.speech.continuous = true;
                this.speech.interimResults = true;
                this.speech.lang = 'en-US';
                this.speech.onresult = (e) => {
                    const t = e.results[e.results.length-1][0].transcript.toUpperCase();
                    if(this.currentGame === 'heads-up' && this.myWord) {
                        if(t.includes(this.myWord)) this.handleWin();
                    }
                };
            }

            selectGame(type) {
                if(networkManager.isHost) {
                    networkManager.send({ type: 'game_start', gameType: type });
                    this.startGame(type);
                }
            }
            
            requestStartGame() {
                if(networkManager.isHost) {
                    this.startActualGameplay();
                    networkManager.send({ type: 'game_update', action: 'start_play' });
                }
            }

            startGame(type) {
                this.currentGame = type;
                ui.showPanel('calibration-panel');
                sceneManager.setEnvironment(type);
                
                if(type === 'heads-up') {
                    document.getElementById('calib-instr').innerText = "Look at camera. Guess word on your head!";
                    if(networkManager.isHost) {
                        const w1 = this.words[Math.floor(Math.random()*this.words.length)];
                        const w2 = this.words[Math.floor(Math.random()*this.words.length)];
                        this.setHeadsUpWord(w1, 'me'); 
                        networkManager.send({ type: 'assign_word', word: w2, target: 'me' }); 
                        setTimeout(() => {
                            networkManager.send({ type: 'assign_word', word: w1, target: 'them' });
                            this.setHeadsUpWord(w2, 'them');
                        }, 500);
                    }
                    if(this.speech) this.speech.start();
                } else {
                    document.getElementById('calib-instr').innerText = "Step back to show full body.";
                }
            }
            
            setHeadsUpWord(word, target) {
                if(target === 'me') {
                    this.myWord = word;
                    sceneManager.updateLabel(null); 
                } else {
                    sceneManager.updateLabel(word); 
                }
            }

            startActualGameplay() {
                this.isPlaying = true;
                ui.hideAllPanels();
                document.getElementById('hud').classList.remove('hidden');
            }

            update(landmarks) {
                if(!this.isPlaying) {
                    const visible = landmarks[11].visibility > 0.5 && landmarks[12].visibility > 0.5;
                    const status = document.getElementById('calib-status');
                    
                    if(visible || (this.currentGame === 'heads-up' && landmarks[0].visibility > 0.8)) {
                        status.style.background = "#003300"; status.style.color = "#00ff00"; status.innerText = "‚úÖ Ready";
                        if(networkManager.isHost) document.getElementById('start-btn').disabled = false;
                        else document.getElementById('start-btn').innerText = "Waiting for Host...";
                    } else {
                        status.style.background = "#330000"; status.style.color = "#ff5555"; status.innerText = "‚ö†Ô∏è Adjust Position";
                        document.getElementById('start-btn').disabled = true;
                    }
                    return;
                }

                if(this.currentGame === 'track') {
                    const energy = visionManager.getMotionEnergy();
                    if(energy > 0.05) this.trackDist += 0.05;
                    networkManager.send({ type: 'game_update', action: 'move', val: this.trackDist });
                    sceneManager.updatePositions(this.trackDist, this.remoteDist);
                    document.getElementById('game-info').innerText = `Me: ${Math.floor(this.trackDist)}m`;
                }
                else if (this.currentGame === 'heads-up') {
                    sceneManager.updateHeadTracking(landmarks);
                    document.getElementById('game-info').innerText = `GUESS THE WORD!`;
                }
            }

            syncState(data) {
                if(data.action === 'move') this.remoteDist = data.val;
                if(data.action === 'start_play') this.startActualGameplay();
                if(data.action === 'win') this.endGame(data.msg);
            }
            
            handleWin() {
                networkManager.send({ type: 'game_update', action: 'win', msg: "Opponent Won!" });
                this.endGame("YOU WON! Word: " + this.myWord);
            }

            endGame(msg) {
                this.isPlaying = false;
                if(this.speech) this.speech.stop();
                document.getElementById('result-text').innerText = msg;
                ui.showPanel('result-panel');
            }
            
            returnToLobby() {
                ui.showPanel('lobby-panel');
                sceneManager.setEnvironment('lobby');
                this.isPlaying = false;
            }
        }

        /* =========================================
           4. VISION MANAGER
           ========================================= */
        class VisionManager {
            constructor() {
                this.canvas = document.getElementById('local-preview');
                this.ctx = this.canvas.getContext('2d');
                this.userCanvas = document.createElement('canvas'); 
                this.userCtx = this.userCanvas.getContext('2d');
                this.video = null;
                this.pose = null;
                this.prevY = 0; this.energy = 0;
            }
            
            async preload() {
                // Initialize MediaPipe silently in background
                this.pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
                this.pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, enableSegmentation: true, minDetectionConfidence: 0.5 });
                this.pose.onResults(this.process.bind(this));
                await this.pose.initialize(); // Helper to warm up
            }

            async startCamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'user', width: {ideal: 640}, height: {ideal: 480} }, 
                        audio: true 
                    });
                    
                    this.video = document.createElement('video');
                    this.video.srcObject = stream;
                    this.video.playsInline = true;
                    this.video.autoplay = true;
                    this.video.muted = true;
                    await this.video.play();
                    
                    this.loop();
                    return true;
                } catch(e) {
                    alert("Camera Permission Denied: " + e.message + "\nPlease refresh and allow access.");
                    return false;
                }
            }
            
            async loop() {
                if(this.video && this.video.readyState >= 2) {
                    await this.pose.send({image: this.video});
                }
                requestAnimationFrame(this.loop.bind(this));
            }
            
            process(results) {
                const trackStatus = document.getElementById('track-status');
                if(!results.poseLandmarks) {
                    trackStatus.style.display = 'block'; 
                    return; 
                } else {
                    trackStatus.style.display = 'none';
                }

                this.canvas.width = this.userCanvas.width = results.image.width;
                this.canvas.height = this.userCanvas.height = results.image.height;
                
                this.userCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.userCtx.drawImage(results.segmentationMask, 0, 0, this.canvas.width, this.canvas.height);
                this.userCtx.globalCompositeOperation = 'source-in';
                this.userCtx.drawImage(results.image, 0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.drawImage(this.userCanvas, 0, 0);
                sceneManager.updateLocalTexture(this.userCanvas);

                if(results.poseLandmarks) {
                    const wy = results.poseLandmarks[15].y;
                    this.energy = Math.abs(wy - this.prevY) * 10;
                    this.prevY = wy;
                    gameManager.update(results.poseLandmarks);
                }
            }

            getStream() { 
                if(this.canvas.width > 0) return this.canvas.captureStream(30); 
                return null;
            }
            getMotionEnergy() { return this.energy; }
        }

        /* =========================================
           5. SCENE MANAGER
           ========================================= */
        class SceneManager {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
                this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.8));
                
                const phGeo = new THREE.PlaneGeometry(2, 1.5);
                const phMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                this.localMesh = new THREE.Mesh(phGeo, phMat);
                this.localMesh.position.set(-1, 0, -3);
                this.scene.add(this.localMesh);

                this.remoteMesh = null;
                this.headLabel = this.createLabel("Waiting...");
                this.headLabel.visible = false;
                this.scene.add(this.headLabel);
                
                this.floor = this.createFloor();
                this.scene.add(this.floor);
                
                this.camera.position.set(0, 1, 0);
                this.animate();
            }

            createAvatarMesh(tex) {
                const geo = new THREE.PlaneGeometry(2, 1.5);
                const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
                return new THREE.Mesh(geo, mat);
            }
            
            createFloor() {
                const geo = new THREE.PlaneGeometry(20, 100);
                const mat = new THREE.MeshBasicMaterial({ color: 0x222222 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.rotation.x = -Math.PI/2;
                mesh.position.y = -1;
                mesh.position.z = -40;
                return mesh;
            }

            createLabel(text) {
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0,0,256,64);
                ctx.fillStyle = '#000000'; ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center'; ctx.fillText(text, 128, 45);
                return new THREE.Mesh(new THREE.PlaneGeometry(1, 0.25), new THREE.MeshBasicMaterial({map: new THREE.CanvasTexture(canvas)}));
            }

            updateLabel(text) {
                if(!text) { this.headLabel.visible = false; return; }
                const ctx = this.headLabel.material.map.image.getContext('2d');
                ctx.fillStyle = 'white'; ctx.fillRect(0,0,256,64);
                ctx.strokeStyle = '#00d2ff'; ctx.lineWidth = 10; ctx.strokeRect(0,0,256,64);
                ctx.fillStyle = 'black'; ctx.fillText(text, 128, 45);
                this.headLabel.material.map.needsUpdate = true;
                this.headLabel.visible = true;
            }

            addRemotePlayer(stream) {
                const video = document.createElement('video');
                video.srcObject = stream; video.play();
                const tex = new THREE.VideoTexture(video);
                if(this.remoteMesh) this.scene.remove(this.remoteMesh);
                this.remoteMesh = this.createAvatarMesh(tex);
                this.remoteMesh.position.set(1, 0, -3);
                this.scene.add(this.remoteMesh);
            }

            updateLocalTexture(canvas) { 
                if(!this.localMesh.material.map && canvas.width > 0) {
                     this.localMesh.material.map = new THREE.CanvasTexture(canvas);
                     this.localMesh.material.needsUpdate = true;
                }
                if(this.localMesh.material.map) this.localMesh.material.map.needsUpdate = true; 
            }

            updatePositions(myDist, theirDist) {
                this.localMesh.position.z = -3 - (myDist * 0.1);
                if(this.remoteMesh) this.remoteMesh.position.z = -3 - (theirDist * 0.1);
                this.camera.position.z = this.localMesh.position.z + 3;
                this.floor.position.z = this.camera.position.z - 40;
            }
            
            updateHeadTracking() {
                if(this.remoteMesh && this.headLabel.visible) {
                    this.headLabel.position.copy(this.remoteMesh.position);
                    this.headLabel.position.y += 0.8;
                }
            }

            setEnvironment(type) {
                this.scene.background = new THREE.Color(type==='lobby'?0x110022 : type==='track'?0x87CEEB : type==='swim'?0x006994 : 0x333333);
                this.floor.visible = (type === 'track');
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                this.renderer.render(this.scene, this.camera);
            }
        }

        /* =========================================
           6. MAIN APP LOGIC
           ========================================= */
        class App {
            constructor() {}
            
            async host() {
                const code = document.getElementById('room-code-input').value.trim();
                if(code.length !== 4) return alert("Please enter a 4-digit code (e.g. 1234)");
                
                const success = await visionManager.startCamera();
                if(success) networkManager.hostRoom(code);
            }

            async join() {
                const code = document.getElementById('room-code-input').value.trim();
                if(code.length !== 4) return alert("Please enter a 4-digit code.");
                
                const success = await visionManager.startCamera();
                if(success) networkManager.joinRoom(code);
            }
        }

        // Initialize Everything in Correct Order
        const ui = new UIManager();
        const visionManager = new VisionManager();
        const sceneManager = new SceneManager();
        const gameManager = new GameManager();
        const networkManager = new NetworkManager();
        const app = new App();

        // Expose to window for HTML buttons
        window.app = app;
        window.gameManager = gameManager;

        // Start initialization
        visionManager.preload().then(() => {
            ui.hideLoader();
            ui.showPanel('main-menu');
        }).catch(e => {
            console.error(e);
            ui.hideLoader();
            ui.showPanel('main-menu');
        });

    </script>
</body>
</html>